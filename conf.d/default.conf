# ----------------------------------------
# HTTP-level logging & helpers
# ----------------------------------------

# Flag kubelet health probes by User-Agent
map $http_user_agent $is_probe { default 0; ~kube-probe 1; }

# Flag error statuses
map $status $is_error { default 0; ~^[45] 1; }

# Only log failing probe requests
map "$is_probe:$is_error" $log_probe_fail { default 0; "1:1" 1; }

# Log all non-probe requests (browsers/APIs)
map $is_probe $not_probe { 0 1; 1 0; }

# JSON access log for normal traffic
log_format json escape=json
  '{'
    '"ts":"$time_iso8601",'
    '"remote":"$remote_addr",'
    '"method":"$request_method",'
    '"uri":"$request_uri",'
    '"status":$status,'
    '"bytes":$body_bytes_sent,'
    '"rt":$request_time,'
    '"ref":"$http_referer",'
    '"ua":"$http_user_agent",'
    '"req_id":"$request_id"'
  '}';

# Compact format for probe logs
log_format probe '$remote_addr - $time_local "$request" $status rt=$request_time';

# Send error logs to stderr
error_log /dev/stderr warn;


# ----------------------------------------
# Main server
# ----------------------------------------
# DNS resolver for proxy_pass
# Works in both Docker (127.0.0.11) and Kubernetes (cluster DNS, typically 10.43.0.10 for k3s)
# nginx will try resolvers in order until one succeeds
resolver 10.43.0.10 127.0.0.11 valid=300s;
resolver_timeout 5s;

server {
  listen 8080;
  server_name _;

  root /usr/share/nginx/html;
  index index.html;

  absolute_redirect off;
  port_in_redirect off;
  server_name_in_redirect off;

  # Access logging:
  access_log /dev/stdout json  if=$not_probe;       # all non-probe requests
  access_log /dev/stdout probe if=$log_probe_fail;  # ONLY failing probes

  # Directory listing for all paths
  location / {
    autoindex on;
    try_files $uri $uri/ =404;
    # Inject scripts into HTML pages
    # Note: sendfile must be off for sub_filter to work properly
    sendfile off;
    
    # Inject scripts before </body> (more reliable - all HTML has </body>, some may lack </head>)
    # Use single line format to avoid potential formatting issues
    sub_filter '</body>' '<script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) };window.plausible.o = { captureOnLocalhost: false, autoCapturePageviews: true};</script><script defer src="https://common.ltc.bcit.ca/js/utils.js"></script></body>';
    
    sub_filter_once on;
    sub_filter_types text/html;
    sub_filter_last_modified on;
  }

  # Health endpoints (match probes)
  location = /healthz {
    access_log off;
    add_header Content-Type application/json;
    return 200 '{"status":"HEALTHY"}';
  }

  location = /healthz/startup {
    access_log off;
    add_header Content-Type application/json;
    return 200 '{"status":"STARTUP_OK"}';
  }

  location = /healthz/ready {
    access_log off;
    add_header Content-Type application/json;
    return 200 '{"status":"READY_OK"}';
  }

  # Proxy Plausible Analytics requests to avoid ad blockers
  # Works from any origin - accepts requests from any domain
  location /api/event {
    # Handle CORS preflight requests first
    # CORS headers MUST be inside the if block for OPTIONS to work properly
    if ($request_method = OPTIONS) {
      add_header Access-Control-Allow-Origin * always;
      add_header Access-Control-Allow-Methods "POST, OPTIONS" always;
      add_header Access-Control-Allow-Headers "Content-Type" always;
      add_header Access-Control-Max-Age 86400 always;
      add_header Content-Length 0 always;
      add_header Content-Type text/plain always;
      return 204;
    }
    
    # Proxy settings with improved error handling
    proxy_pass https://plausible.io/api/event;
    proxy_http_version 1.1;
    
    # Preserve original request headers
    proxy_set_header Host plausible.io;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header Connection "";
    
    # Don't override Content-Type - let the client send it
    # The client sends "text/plain" which is what Plausible expects
    
    # Timeouts to prevent hanging requests
    proxy_connect_timeout 10s;
    proxy_send_timeout 10s;
    proxy_read_timeout 10s;
    
    # Disable buffering for real-time forwarding
    proxy_buffering off;
    proxy_cache off;
    
    # Ensure response is properly forwarded to client
    proxy_ignore_headers "Cache-Control" "Expires";
    proxy_hide_header "Cache-Control";
    proxy_hide_header "Expires";
    
    # CORS headers for POST requests - MUST be after proxy_pass to work with proxied responses
    # The 'always' parameter ensures headers are added even for proxied responses (including 202)
    add_header Access-Control-Allow-Origin * always;
    add_header Access-Control-Allow-Methods "POST, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Content-Type" always;
    
    # SSL settings for HTTPS proxy
    proxy_ssl_verify on;
    proxy_ssl_verify_depth 2;
    proxy_ssl_server_name on;
    proxy_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
    proxy_ssl_session_reuse on;
    
    # Handle proxy errors gracefully with CORS headers
    # Intercept errors so we can add CORS headers even on failures
    proxy_intercept_errors on;
    error_page 400 401 403 404 500 502 503 504 = @proxy_error;
  }

  # Error handler that ensures CORS headers are present even on proxy failures
  # Returns 200 OK to prevent CORS errors in browser, analytics failures are non-critical
  location @proxy_error {
    internal;
    add_header Access-Control-Allow-Origin * always;
    add_header Access-Control-Allow-Methods "POST, OPTIONS" always;
    add_header Access-Control-Allow-Headers "Content-Type" always;
    add_header Content-Type text/plain always;
    return 200 "OK";
  }

  # Optional nice to haves
  sendfile on;
  keepalive_timeout 65s;
}
